from typing import Any, Optional
from datetime import datetime, timezone, date
from pydantic import BaseModel, ConfigDict
from sqlmodel import (
    Index,
    Field,
    SQLModel,
    UniqueConstraint,
    Column,
    DateTime,
    String,
    ARRAY,
    JSON,
    Relationship,
    Date,
)
from pgvector.sqlalchemy import Vector
import sqlalchemy as sa


import database.enums as enums


class ClassInfo(BaseModel):
    """Maps subjects to their grade levels for a teacher"""

    model_config = ConfigDict(arbitrary_types_allowed=True)

    classes: dict[str, list[str]]  # keys=Subject, values=List[GradeLevel]

    """ METHODS """

    def model_dump(self, **kwargs):
        data = super().model_dump(**kwargs)
        return {
            subject: [grade for grade in grades]
            for subject, grades in data["classes"].items()
        }


class User(SQLModel, table=True):
    __tablename__ = "users"  # type: ignore
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    # The id is optional because it will be generated by the database
    id: Optional[int] = Field(default=None, primary_key=True)
    name: Optional[str] = Field(max_length=50)
    wa_id: str = Field(max_length=20, unique=True, index=True)
    state: enums.UserState = Field(default=enums.UserState.NEW, max_length=50)
    onboarding_state: Optional[enums.OnboardingState] = Field(
        default=enums.OnboardingState.NEW, max_length=50
    )
    role: enums.Role = Field(default=enums.Role.TEACHER, max_length=20)
    class_info: Optional[dict[str, list[str]]] = Field(default=None, sa_type=JSON)
    school_name: Optional[str] = Field(default=None, max_length=100)
    birthday: Optional[date] = Field(default=None, sa_type=Date)
    region: Optional[str] = Field(default=None, max_length=50)
    last_message_at: Optional[datetime] = Field(default=None, sa_type=sa.DateTime(timezone=True))  # type: ignore
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
    )
    updated_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={
            "onupdate": lambda: datetime.now(timezone.utc),
        },
        nullable=False,
    )

    """ RELATIONSHIPS """
    # A teacher may have entries in the teachers_classes table
    taught_classes: Optional[list["TeacherClass"]] = Relationship(
        back_populates="teacher_", cascade_delete=True  # Could rename to user_
    )

    # A teacher may have entries in the messages table
    user_messages: Optional[list["Message"]] = Relationship(
        back_populates="user_", cascade_delete=True
    )


class Subject(SQLModel, table=True):
    __tablename__ = "subjects"  # type: ignore
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    name: enums.SubjectName = Field(max_length=50, nullable=False)

    """ RELATIONSHIPS """
    # A subject may have entries in the classes table
    subject_classes: Optional[list["Class"]] = Relationship(
        back_populates="subject_", cascade_delete=True
    )


class Class(SQLModel, table=True):
    __tablename__ = "classes"  # type: ignore
    __table_args__ = (
        UniqueConstraint("subject_id", "grade_level", name="unique_classes"),
    )
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    subject_id: int = Field(foreign_key="subjects.id", index=True, ondelete="CASCADE")
    grade_level: enums.GradeLevel = Field(max_length=10, index=True)
    status: enums.SubjectClassStatus = Field(default=enums.SubjectClassStatus.ACTIVE)

    """ RELATIONSHIPS """
    # A class may have entries in the teachers_classes table
    class_teachers: Optional[list["TeacherClass"]] = Relationship(
        back_populates="class_", cascade_delete=True
    )
    # A class may have entries in the classes_resources table
    class_resources: Optional[list["ClassResource"]] = Relationship(
        back_populates="class_", cascade_delete=True
    )
    # Relationship to the Subject table (since the Subject is a foreign key)
    subject_: Subject = Relationship(back_populates="subject_classes")


class TeacherClass(SQLModel, table=True):
    __tablename__ = "teachers_classes"  # type: ignore
    __table_args__ = (
        UniqueConstraint("teacher_id", "class_id", name="unique_teacher_class"),
    )

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    teacher_id: int = Field(foreign_key="users.id", index=True, ondelete="CASCADE")
    class_id: int = Field(foreign_key="classes.id", index=True, ondelete="CASCADE")

    """ RELATIONSHIPS """
    class_: Class = Relationship(back_populates="class_teachers")
    teacher_: User = Relationship(back_populates="taught_classes")


class Message(SQLModel, table=True):
    __tablename__ = "messages"  # type: ignore
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="users.id", index=True, ondelete="CASCADE")
    role: enums.MessageRole = Field(max_length=20)
    content: Optional[str] = Field(default=None)  # None when tool_calls present

    # Tool call related fields
    tool_calls: Optional[list[dict]] = Field(default=None, sa_column=Column(JSON))
    tool_call_id: Optional[str] = Field(default=None)
    tool_name: Optional[str] = Field(default=None, max_length=50)
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
        index=True,
    )

    # Future fields
    # NOTE: add a field for message type (eg. text/image/pdf)
    # NOTE: add a field for the content embedding for when we start doing RAG on chat history

    """ RELATIONSHIPS """
    user_: "User" = Relationship(back_populates="user_messages")

    """ METHODS """

    def to_api_format(self) -> dict[str, Any]:
        """Convert message to OpenAI API format"""
        message: dict[str, Any] = {"role": self.role.value}
        if self.tool_calls and len(self.tool_calls) > 0:
            message["tool_calls"] = self.tool_calls
            message["content"] = None
        if self.content is not None:
            message["content"] = self.content
        if self.tool_call_id is not None:
            message["tool_call_id"] = self.tool_call_id
        if self.tool_name is not None:
            message["name"] = self.tool_name

        return message

    @classmethod
    def from_api_format(cls, data: dict, user_id: int) -> "Message":
        """Create message from OpenAI API format"""
        tool_calls = data.get("tool_calls")
        if len(data["tool_calls"]) == 0:
            tool_calls = None

        message_data = {
            "user_id": user_id,
            "role": data["role"],
            "content": data.get("content"),
            "tool_calls": tool_calls,
            "tool_call_id": data.get("tool_call_id"),
            "tool_name": data.get("name"),
        }
        return cls(**message_data)


class Resource(SQLModel, table=True):
    __tablename__ = "resources"  # type: ignore
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str = Field(max_length=100)
    type: Optional[enums.ResourceType] = Field(max_length=30)
    authors: Optional[list[str]] = Field(sa_column=Column(ARRAY(String(50))))
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
    )

    """ RELATIONSHIPS """
    resource_classes: Optional[list["ClassResource"]] = Relationship(
        back_populates="resource_", cascade_delete=True
    )
    # resource_sections: Optional[List["Section"]] = Relationship(
    #     back_populates="resource_", cascade_delete=True
    # )
    resource_chunks: Optional[list["Chunk"]] = Relationship(
        back_populates="resource_", cascade_delete=True
    )


class ClassResource(SQLModel, table=True):
    __tablename__ = "classes_resources"  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    class_id: int = Field(foreign_key="classes.id", index=True, ondelete="CASCADE")
    resource_id: int = Field(foreign_key="resources.id", index=True, ondelete="CASCADE")

    """ RELATIONSHIPS """
    class_: Class = Relationship(back_populates="class_resources")
    resource_: Resource = Relationship(back_populates="resource_classes")


class Chunk(SQLModel, table=True):
    __tablename__ = "chunks"  # type: ignore
    __table_args__ = (
        Index(
            "chunk_embedding_idx",  # index name
            "embedding",  # column name
            postgresql_using="hnsw",
            postgresql_with={"m": 16, "ef_construction": 64},
            postgresql_ops={"embedding": "vector_cosine_ops"},
        ),
    )
    model_config = {"arbitrary_types_allowed": True}  # type: ignore

    """ FIELDS """
    id: Optional[int] = Field(default=None, primary_key=True)
    resource_id: int = Field(foreign_key="resources.id", index=True, ondelete="CASCADE")
    # section_id: Optional[int] = Field(
    #     foreign_key="sections.id", index=True, ondelete="CASCADE", default=None
    # )
    content: str
    page_number: Optional[int] = Field(default=None)
    # TODO: Define the different types of chunks in an enum
    chunk_type: Optional[enums.ChunkType] = Field(max_length=30, default=None)
    """
    XXX: FILL IN THE EMBEDDING LENGTH FOR YOUR EMBEDDINGS
    - Default is set to 1024 (for bge-large vectors)
    - Replace with 1536 for text-embedding-3-small if using OpenAI's embedder
    """
    embedding: Any = Field(sa_column=Column(Vector(1024)))
    top_level_section_index: Optional[str] = Field(max_length=10, default=None)
    top_level_section_title: Optional[str] = Field(max_length=100, default=None)
    created_at: Optional[datetime] = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_type=DateTime(timezone=True),  # type: ignore
        sa_column_kwargs={"server_default": sa.func.now()},
        nullable=False,
    )

    """ RELATIONSHIPS """
    resource_: Optional["Resource"] = Relationship(back_populates="resource_chunks")
    # section_: Optional["Section"] = Relationship(back_populates="section_chunks")
